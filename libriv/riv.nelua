## pragmas.unitname = ''
## linklib 'riv'

require 'riv_types'

global argc: cint <cimport'argc',nodecl>
global argv: *[0]cstring <cimport'argv',nodecl>

-- util
global function riv_version(): uint64 <cimport,nodecl> end
global function riv_rdcycle(): uint64 <cimport,nodecl> end
global function riv_printf(format: cstring <const>, ...: cvarargs): usize <cimport,nodecl> end
global function riv_snprintf(s: cstring, maxlen: usize, format: cstring <const>, ...: cvarargs): usize <cimport,nodecl> end

-- basic
global function riv_get_context(): *riv_context <cimport,nodecl> end
global function riv_setup(argc: int32, argv: *[0]cstring): void <cimport,nodecl> end
global function riv_shutdown(): void <cimport,nodecl> end
global function riv_present(): void <cimport,nodecl> end
global function riv_run(desc: *riv_run_desc): void <cimport,nodecl> end
global function riv_quit(): void <cimport,nodecl> end

global function riv_get_frame(): uint64 <cimport,nodecl> end
global function riv_get_millis(): int64 <cimport,nodecl> end
global function riv_get_seconds(): float64 <cimport,nodecl> end
global function riv_get_width(): uint32 <cimport,nodecl> end
global function riv_get_height(): uint32 <cimport,nodecl> end
global function riv_get_target_fps(): uint32 <cimport,nodecl> end
global function riv_get_framebuffer(): *[0]uint8 <cimport,nodecl> end
global function riv_get_palette(): *[0]uint32 <cimport,nodecl> end

-- drawing
global function riv_clear_screen(col: uint32): void <cimport,nodecl> end
global function riv_draw_pixel(x: uint32, y: uint32, col: uint32): void <cimport,nodecl> end

-- io card
global function riv_get_incard(): riv_span_uint8 <cimport,nodecl> end
global function riv_set_outcard(card: riv_span_uint8): void <cimport,nodecl> end
global function riv_get_inoutbuffer(): *[0]uint8 <cimport,nodecl> end

-- input system
global function riv_set_tracked_keys(tracked_keys: riv_span_uint8): void <cimport,nodecl> end
global function riv_get_key_state(keycode: uint8): riv_key_state <cimport,nodecl> end
global function riv_is_key_down(keycode: uint8): boolean <cimport,nodecl> end
global function riv_is_key_up(keycode: uint8): boolean <cimport,nodecl> end
global function riv_is_key_press(keycode: uint8): boolean <cimport,nodecl> end
global function riv_is_key_release(keycode: uint8): boolean <cimport,nodecl> end

-- sound system
global function riv_make_sound_buffer(desc: *riv_sound_buffer_desc): uint64 <cimport,nodecl> end
global function riv_destroy_sound_buffer(id: uint64): void <cimport,nodecl> end
global function riv_sound(desc: *riv_sound_desc): uint64 <cimport,nodecl> end
global function riv_waveform(desc: *riv_waveform_desc): uint64 <cimport,nodecl> end

-- prng
global function riv_srand(a: uint64, b: uint64): void <cimport,nodecl> end
global function riv_rand(): uint64 <cimport,nodecl> end
global function riv_rand_uint(high: uint64): uint64 <cimport,nodecl> end
global function riv_rand_int(low: int64, high: int64): int64 <cimport,nodecl> end
global function riv_rand_float(): float64 <cimport,nodecl> end

-- Macro for generating tiny binaries.
## function nostartfiles(libc) cflags '-nostartfiles'
  local function _start() <entrypoint,noreturn,cattribute'externally_visible,naked'>
    ##[=[ cemit[[
  asm volatile(
    ".weak __global_pointer$;\n"
    ".hidden __global_pointer$;\n" // don't export symbol
    ".option push;\n"
    ".option norelax;\n"
    "la gp, __global_pointer$;\n"
    "mv a0, sp;\n" // stack pointer
    "lw a1, 0(sp);\n" // argc
    "addi a2, sp, 8;\n" // argv
    "andi sp, sp, -16;\n" // make stack 16-byte aligned
    ".option pop;\n"
  );
]] ]=]
    local argc: cint <register'a1',nodce,noinit>
    local argv: *[0]cstring <register'a2',nodce,noinit>
    local function nelua_main(argc: cint, argv: *cstring): cint <cimport,nodecl,noinline> end
    ## if libc then
      local main_callback: type = @function(cint, *cstring): cint
      local function __libc_start_main(main: main_callback, argc: cint, argv: pointer, init: pointer, fini: pointer, rtld_fini: pointer, stack_end: pointer) <cimport,noreturn> end
      local sp: pointer <register'a0',nodce,noinit>
      __libc_start_main(nelua_main, (@cint)(argc), argv, nilptr, nilptr, nilptr, sp)
    ## else
      local res: cint = nelua_main(argc, argv)
      local function exit_syscall(status: isize): void <inline,noreturn>
        local a0: isize <register'a0',nodce> = status
        ## cemit[[  asm volatile("li a7, 93; scall; ebreak;" : : "r"(a0));]]
        ## cemit[[__builtin_unreachable();]]
      end
      exit_syscall(res)
    ## end
  end
## end
