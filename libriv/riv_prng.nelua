## pragmas.unitname = ''

require 'murmur3'
require '.riv_impl_types'
require '.riv_xoshiro256'

local span_uint8: type = @span(uint8)

global function riv_init_prng(argc: int32, argv: *[0]cstring): void
  local hash: [2]uint64 = {riv.incard_len, riv.incard_len}
  if riv.incard_len > 0 then
    hash = murmur3_128(span_uint8{data=(riv.inoutbuffer), size=riv.incard_len}, hash)
  end
  if argc > 0 and argv ~= nilptr then
    for i: int32=1,<argc do
      if argv[i] ~= nilptr then
        hash = murmur3_128(span_uint8{data=(@*[0]uint8)(argv[i]), size=#argv[i]}, hash)
      end
    end
  end
  riv.prng:srand(hash[0], hash[1])
end

-- Generates a random unsigned integer in interval [0, UINT64_MAX].
global function riv_rand(): uint64 <cexport>
  return riv.prng:rand()
end

-- Generates a random unsigned integer in interval [0, `high`].
global function riv_rand_uint(high: uint64): uint64 <cexport>
  return riv.prng:rand_uint(high)
end

-- Returns a pseudo-random integer with uniform distribution in the range [`low`, `high`].
global function riv_rand_int(low: int64, high: int64): int64 <cexport>
  return riv.prng:rand_int(low, high)
end

-- Generates a random floating-point number in interval [0, 1).
global function riv_rand_float(): float64 <cexport>
  return riv.prng:rand_float()
end

-- Reinitialize the generator seed.
global function riv_srand(a: uint64, b: uint64): void <cexport>
  riv.prng:srand(a, b)
end
