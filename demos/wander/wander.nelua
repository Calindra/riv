## pragma{nogc = true, noerrorloc = true}

require 'riv'
require 'math'

local TILE_SIZE <comptime> = 16
local MAP_SIZE <comptime> = 16
riv.width = TILE_SIZE*MAP_SIZE
riv.height = TILE_SIZE*MAP_SIZE

local sps_id: uint64 = riv_make_spritesheet(riv_make_image("wander.png", 0), TILE_SIZE, TILE_SIZE)
local x: float32, y: float32 = MAP_SIZE // 2, MAP_SIZE // 2   -- position (in tiles)
local dx: float32, dy: float32 = 0.0, 0.0 -- velocity
local f: float32 = 0.0                    -- frame number
local d: int64 = 1                        -- direction (-1, 1)
local room_x: int64 = 0
local room_y: int64 = 0

local map: [MAP_SIZE][MAP_SIZE]uint8 = {
  {0xd,0xb,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe},
  {0xc,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe},
  {0xe,0xe,0xe,0xc,0xe,0xe,0xe,0xa,0xe,0xe,0xb,0xe,0xe,0xe,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xc,0xc,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xf,0xe},
  {0xc,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xa,0xe,0xf,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xf,0xb,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xf,0xe,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xc,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xa,0xe,0xe,0xe,0xe,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xf,0xe,0xe},
  {0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe},
  {0xe,0xc,0xe,0xe,0xe,0xf,0xe,0xe,0xe,0xe,0xc,0xe,0xe,0xe,0xe,0xe},
  {0xe,0xe,0xe,0xf,0xf,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xf},
  {0xe,0xe,0xe,0xc,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0xd,0xe,0xf,0xe},
  {0xe,0xd,0xe,0xe,0xf,0xe,0xe,0xe,0xe,0xe,0xe,0xc,0xe,0xe,0xe,0xe},
}

local function draw()
  -- draw map
  for y=0,<MAP_SIZE do
    for x=0,<MAP_SIZE do
      riv_draw_sprite(map[y][x], sps_id, x*TILE_SIZE, y*TILE_SIZE, 1, 1, 1, 1)
    end
  end

  -- draw the player
  riv_draw_sprite(1 + math.ifloor(f), sps_id, -- n, sps_id
                  math.ifloor(x*TILE_SIZE-TILE_SIZE//2), math.ifloor(y*TILE_SIZE-TILE_SIZE//2), -- x, y
                  1, 1, d, 1) -- w,h, mw, mh

  riv.draw.origin = {0, 0}
  riv_draw_text("COLLECT THE COINS!", RIV_SPRITESHEET_FONT_5X7, RIV_TOPLEFT, TILE_SIZE//2, TILE_SIZE//2, 1, RIV_COLOR_WHITE)
end

local function update()
  local ac=0.1_f32 -- acceleration

  if riv.keys[RIV_GAMEPAD_LEFT].down then dx = dx-ac d = -1 end
  if riv.keys[RIV_GAMEPAD_DOWN].down then dy = dy + ac end
  if riv.keys[RIV_GAMEPAD_RIGHT].down then dx = dx + ac d=1 end
  if riv.keys[RIV_GAMEPAD_UP].down then dy = dy -ac end

  -- move (add velocity)
  x = math.clamp(x + dx, 0, MAP_SIZE-0.05_f32)
  y = math.clamp(y + dy, 0, MAP_SIZE-0.05_f32)

  -- friction (lower for more)
  dx = dx * .7_f32
  dy = dy * .7_f32

  -- advance animation according
  -- to speed (or reset when
  -- standing almost still)
  local spd = math.sqrt(dx*dx+dy*dy)
  f = (f+spd*2) % 4 -- 4 frames
  if spd < 0.05_f32 then
    f=0
  end

  -- collect apple
  if map[math.ifloor(y)][math.ifloor(x)] == 10 then
    map[math.ifloor(y)][math.ifloor(x)] = 14
    riv_waveform(riv_waveform_desc{
      type = RIV_WAVEFORM_PULSE,
      attack = 0.01,
      decay = 0.01,
      sustain = 0.1,
      release = 0.01,
      start_frequency = 220,
      end_frequency = 220*3,
      amplitude = 0.5,
      sustain_level = 0.5,
    })
  end

end

repeat update() draw() until not riv_present()
