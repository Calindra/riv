require 'riv'

-- Game types
local Point2D = @record{x: int32, y: int32}
local Direction = @enum(byte){NONE=0, UP, DOWN, RIGHT, LEFT}
local Color = @byte

-- Game constants
local TILE_SIZE <comptime> = 1
local GRID_SIZE <comptime> = 16
local SCREEN_SIZE <comptime> = TILE_SIZE * GRID_SIZE
local MOVE_DELAY <comptime> = 3

-- Game state variables
local riv: *riv_context
local nextmove: uint64
local headpos: Point2D, tailpos: Point2D, applepos: Point2D
local score: uint32
local movedir: Direction
local tiles: [GRID_SIZE][GRID_SIZE]Direction
local last_turn_frame: uint64

local function move_point(pos: Point2D, dir: Direction)
  switch dir
  case Direction.UP then
    pos.y = pos.y - 1
  case Direction.DOWN then
    pos.y = pos.y + 1
  case Direction.RIGHT then
    pos.x = pos.x + 1
  case Direction.LEFT then
    pos.x = pos.x - 1
  end
  return pos
end

local function set_tile(pos: Point2D, dir: Direction)
  tiles[pos.x][pos.y] = dir
end

local function reset_tile(pos: Point2D)
  tiles[pos.x][pos.y] = Direction.NONE
end

local function get_tile(pos: Point2D)
  return tiles[pos.x][pos.y]
end

local function has_tile(pos: Point2D)
  return tiles[pos.x][pos.y] ~= Direction.NONE
end

local function respawn_apple()
  -- return when there is not enough space to spawn anymore
  if score + 2 >= GRID_SIZE * GRID_SIZE then return end
  -- respawn until there is no collision with its body
  repeat
    applepos = Point2D{
      x = riv.prng:rand_uint(GRID_SIZE-1),
      y = riv.prng:rand_uint(GRID_SIZE-1)
    }
  until not has_tile(applepos)
end

local function save_score(finished: boolean)
  local finished_str: string = finished and 'true' or 'false'
  riv.outcard_len = riv_snprintf(riv.inoutbuffer, RIV_MEMSIZE_INOUTBUFFER, [[{"score": %u, "finished": %s}]], score, finished_str)
  riv.outcard_format = RIV_CARDFORMAT_JSON
end

local function init_game()
  tiles = {}
  headpos = Point2D{x=GRID_SIZE//2, y=GRID_SIZE//2}
  tailpos = Point2D{x=headpos.x,    y=headpos.y+1}
  movedir = Direction.UP
  nextmove = 0
  score = 0
  save_score(false)
  set_tile(headpos, Direction.UP)
  set_tile(tailpos, Direction.UP)
  respawn_apple()
  riv_printf('[SNAKE] NEW GAME\n')
end

local function game_over()
  save_score(true)
  riv_printf('[SNAKE] GAME OVER\n')
  riv.quit = true
  -- init_game()
end

local function check_turn(keycode: uint8, dir: Direction)
  if not riv.keys[keycode].press then return end
  local frame = riv.keys[keycode].down_frame
  if frame < last_turn_frame then return end
  local headdir = get_tile(headpos)
  switch dir do
  case Direction.UP then if headdir == Direction.DOWN then return end
  case Direction.DOWN then if headdir == Direction.UP then return end
  case Direction.LEFT then if headdir == Direction.RIGHT then return end
  case Direction.RIGHT then if headdir == Direction.LEFT then return end
  else return end
  movedir = dir
  last_turn_frame = frame
end

local function poll_events()
  check_turn(RIV_KEYCODE_UP, Direction.UP)
  check_turn(RIV_KEYCODE_DOWN, Direction.DOWN)
  check_turn(RIV_KEYCODE_RIGHT, Direction.RIGHT)
  check_turn(RIV_KEYCODE_LEFT, Direction.LEFT)
end

local function poll_game()
  local now = riv.frame
  if now < nextmove then return end
  nextmove = now + MOVE_DELAY

  -- move the head
  set_tile(headpos, movedir)
  headpos = move_point(headpos, movedir)

  -- check collision with map boundaries
  if headpos.x >= GRID_SIZE or headpos.y >= GRID_SIZE or
     headpos.x < 0 or headpos.y < 0 then
    game_over()
    return
  end

  -- check collisions with its body
  if has_tile(headpos) then
    game_over()
    return
  end

  -- place head on next tile
  set_tile(headpos, movedir)

  -- check collision with apple
  if headpos.x == applepos.x and headpos.y == applepos.y then
    score = score + 1
    save_score(false)
    riv_printf('[SNAKE] SCORE %u\n', score)
    respawn_apple()
  else
    -- eat tail
    local taildir = get_tile(tailpos)
    reset_tile(tailpos)
    tailpos = move_point(tailpos, taildir)
  end
end

local function draw_background(color: Color)
  local framebuffer = riv.framebuffer
  for i=0,<SCREEN_SIZE*SCREEN_SIZE do
    framebuffer[i] = color
  end
end

local function draw_tile(pos: Point2D, color: Color)
  local framebuffer = riv.framebuffer
  local xoff, yoff = pos.x*TILE_SIZE, pos.y*TILE_SIZE
  for y=yoff,<yoff+TILE_SIZE do
    for x=xoff,<xoff+TILE_SIZE do
      framebuffer[y*SCREEN_SIZE + x] = color
    end
  end
end

local function draw_apple()
  draw_tile(applepos, RIV_PAL16_RED)
end

local function draw_snake()
  for x=0,GRID_SIZE-1 do
    for y=0,GRID_SIZE-1 do
      local pos = Point2D{x=x,y=y}
      if has_tile(pos) then -- snake is present at this tile
        draw_tile(pos, RIV_PAL16_GREEN)
      end
    end
  end
end

local function draw()
  draw_background(RIV_PAL16_DARKBLUE)
  draw_apple()
  draw_snake()
end

local function frame(ctx: *riv_context)
  poll_events()
  poll_game()
  draw()
end

local function init(ctx: *riv_context)
  riv = ctx
  init_game()
  for i=0,<RIV_NUM_KEYCODE do
    riv.tracked_keys[i] = false
  end
  riv.tracked_keys[RIV_KEYCODE_UP] = true
  riv.tracked_keys[RIV_KEYCODE_DOWN] = true
  riv.tracked_keys[RIV_KEYCODE_LEFT] = true
  riv.tracked_keys[RIV_KEYCODE_RIGHT] = true
end

riv_run(&(@riv_run_desc){
  init_cb = init,
  frame_cb = frame,
  framebuffer_desc = {
    width = SCREEN_SIZE,
    height = SCREEN_SIZE,
    fps = 24,
    pixel_format = RIV_PIXELFORMAT_PAL256,
  }
})

## nostartfiles()
