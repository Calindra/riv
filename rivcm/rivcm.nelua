-- This file contains all code related to the audio subsystem.

require 'string'
require 'io'
require 'os'
require 'arg'
require 'sokol'
require 'vector'

require '.machine'
require '.audio'
require '.video'
require '.input'
require '.framelimiter'

local rivcm_options: type = @record{
  cartridge: string,
  entrypoint: string,
  replay_filename: string,
  recording: boolean,
  replaying: boolean,
  speed: float64,
}

local function parse_options(): rivcm_options
  local opts: rivcm_options = {
    speed = 1.0
  }
  local entrypoint_args: boolean = false
  local entrypoint_sb: stringbuilder <close>
  local argi: usize = 1
  while argi <= #arg do
    local a: string = arg[argi]
    if not entrypoint_args then
      if a == '-record' then
        assert(not opts.replaying, 'already replaying')
        assert(argi + 1 <= #arg, 'missing filename parameter')
        opts.recording = true
        opts.replay_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-replay' then
        assert(not opts.recording, 'already recording')
        assert(argi + 1 <= #arg, 'missing filename parameter')
        opts.replaying = true
        opts.replay_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-cartridge' then
        assert(argi + 1 <= #arg, 'missing filename parameter')
        entrypoint_sb:write('cartridge-run')
        opts.cartridge = arg[argi + 1]
        argi = argi + 1
      elseif a == '-speed' then
        assert(argi + 1 <= #arg, 'missing speed parameter')
        local numstr: string = arg[argi + 1]
        assert(numstr:find('^[0-9]+%.?[0-9]*$') > 0, 'malformed speed number')
        opts.speed = tonumber(arg[argi + 1])
        assert(opts.speed > 0.0, 'speed must be positive')
        argi = argi + 1
      elseif a == '--' then
        entrypoint_args = true
      elseif a == '--help' then
        io.stderr:printf("Usage: %s [options]\n", arg[0])
        io.stderr:write[[
-cartridge <filename>
    Cartridge to run.

-record <filename>
    Record game to an input log.

-replay <filename>
    Replay game from an input log.

-speed <speed>
    Set replay speed.
]]
        os.exit(0)
      else
        error(string.format("unknown command line option '%s'", a))
      end
    else
      entrypoint_sb:write(' ', a)
    end
    argi = argi + 1
  end
  opts.entrypoint = entrypoint_sb:promote()
  return opts
end

local options: rivcm_options
local framelimiter: riv_framelimiter

-- Initialize application.
local function init(): void
  -- initialize the machine
  machine = Machine.create(options.cartridge, options.entrypoint)

  -- init subsystems
  video.setup()
  audio.setup()
  input.setup()

  if options.recording then -- start recording
    input.start_recording()
  elseif options.replaying then -- start replaying
    input.load_replay(options.replay_filename)
  end
end

-- Terminate application.
local function terminate(): void
  if options.recording then
    input.save_replay(options.replay_filename)
  end

  input.shutdown()
  video.shutdown()
  audio.shutdown()

  local mcycle: uint64 = machine:read_mcycle()
  local root_hash: string <close> = hexhash(machine:get_root_hash_as_hex())
  io.stderr:printf('%d: %s\n', mcycle, root_hash)
  machine:destroy()
end

-- Run the machine until it yields the next frame.
local function machine_frame(): void
  while true do
    switch machine:run() do
    case CM_BREAK_REASON_YIELDED_AUTOMATICALLY then
      -- execute control event from the yield
      switch machine:read_yield_reason() do
      case RIV_CONTROL_PRESENT then
        -- copy frame buffer from guest memory into host memory
        video.update_framebuffer()
        -- must break the loop so we can present the video
        return
      case RIV_CONTROL_AUDIO then
        audio.control()
      else
        error 'unknown yield reason'
      end
    case CM_BREAK_REASON_HALTED then
      io.stderr:printf('Halted\n')
      sapp_quit()
      return
    else
      io.stderr:printf('Unexpected machine run break reason\n')
      sapp_quit()
      return
    end
  end
end

-- Advance to the next frame.
local function advance_frame(): void
  if machine:is_halted() then return end

  -- check if is the last replay frame
  local finished: boolean = input.is_replay_at_end()

  -- poll input events into machine device memory
  input.poll()

  -- poll next frame from machine driver memory
  local mcycle_start: uint64 = machine:read_mcycle()
  local time_start: float64 = os.now()
  machine_frame()
  local now: float64 = os.now()
  local time_elapsed: float64 = now - time_start
  local mcycle_elapsed: uint64 = machine:read_mcycle() - mcycle_start

  -- force quit when replay ends
  if finished then
    io.stderr:printf('Replay finished\n')
    sapp_quit()
  end

  -- log fps
  if machine:is_mmio_ready() then
    framelimiter.max_fps = machine.mmio_driver.framebuffer_desc.fps * options.speed
    framelimiter:print_stats(now, time_elapsed, mcycle_elapsed)
  end
end

-- Poll next frame.
local function frame(): void
  -- TODO: get display refresh rate
  local refresh_rate: float64 = 60
  if not machine:is_mmio_ready() then -- first frame
    advance_frame()
    framelimiter.last_frame_time = os.now()
  elseif framelimiter.max_fps <= refresh_rate then
    if framelimiter:should_process_next_frame(os.now()) then
      advance_frame()
    end
  else -- FPS is too big, advance any frames at once
    local now_start: float64 = os.now()
    local now_end: float64 = now_start + (1.0 / refresh_rate)
    local dt: float64 = 1.0 / (refresh_rate * options.speed)
    for now=now_start,<now_end,dt do
      if framelimiter:should_process_next_frame(now) then
        -- advance to next frame
        advance_frame()
      end
    end
  end
  -- display the frame
  video.present()
end

do
  -- parse options
  options = parse_options()

  -- Application main loop.
  sapp_run(sapp_desc{
    init_cb = init,
    frame_cb = frame,
    cleanup_cb = terminate,
    event_cb = input.append_event,
    width = 320,
    height = 240,
    window_title = "RIVCM",
  })
end
