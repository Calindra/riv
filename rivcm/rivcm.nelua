-- This file contains all code related to the audio subsystem.

##[[
pragma{
  nogc=true,
}
libpath(fs.join(fs.scriptdir(2), 'libriv', '?.nelua'))
libpath(fs.join(fs.scriptdir(2), 'libs', 'host', '?.nelua'))
libpath(fs.join(fs.scriptdir(2), 'libs', 'guest-host', '?.nelua'))
]]

require 'string'
require 'io'
require 'os'
require 'arg'
require 'sokol'

require '.machine'
require '.audio'
require '.video'
require '.input'
require '.framelimiter'
require '.iocard'

local rivcm_options: type = @record{
  entrypoint: string,
  cartridge_filename: string,
  replay_filename: string,
  incard_filename: string,
  outcard_filename: string,
  outhash_filename: string,
  recording: boolean,
  replaying: boolean,
  print_stats: boolean,
  speed: float64,
}

local function parse_options(): rivcm_options
  local opts: rivcm_options = {
    speed = 1.0
  }
  local entrypoint_args: boolean = false
  local entrypoint_sb: stringbuilder <close>
  local argi: usize = 1
  while argi <= #arg do
    local a: string = arg[argi]
    if not entrypoint_args then
      if a == '-record' then
        assert(not opts.replaying, 'already replaying')
        assert(argi + 1 <= #arg, 'missing parameter for option -record')
        opts.recording = true
        opts.replay_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-replay' then
        assert(not opts.recording, 'already recording')
        assert(argi + 1 <= #arg, 'missing parameter for option -replay')
        opts.replaying = true
        opts.replay_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-cartridge' then
        assert(argi + 1 <= #arg, 'missing parameter for option -cartridge')
        entrypoint_sb:write('cartridge-run')
        opts.cartridge_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-load-incard' then
        assert(argi + 1 <= #arg, 'missing parameter for option -load-incard')
        opts.incard_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-save-outcard' then
        assert(argi + 1 <= #arg, 'missing parameter for option -save-outcard')
        opts.outcard_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-save-outhash' then
        assert(argi + 1 <= #arg, 'missing parameter for option -save-outhash')
        opts.outhash_filename = arg[argi + 1]
        argi = argi + 1
      elseif a == '-speed' then
        assert(argi + 1 <= #arg, 'missing parameter for option -speed')
        local numstr: string = arg[argi + 1]
        assert(numstr:find('^[0-9]+%.?[0-9]*$') > 0, 'malformed speed number')
        opts.speed = tonumber(arg[argi + 1])
        assert(opts.speed > 0.0, 'speed must be positive')
        argi = argi + 1
      elseif a == '-print-stats' then
        opts.print_stats = true
      elseif a == '--' then
        entrypoint_args = true
      elseif a == '-help' or a == '--help' or a == '-h' then
        io.stderr:printf("Usage: %s [options]\n", arg[0])
        io.stderr:write[[
-print-fps
    Print frame rate statistics every second.

-cartridge <filename>
    Cartridge to run.

-load-incard <filename>
    Load input card from a file.

-save-outcard <filename>
    Save output card to a file.

-save-outhash <filename>
    Save output card Keccak-256 hash to a file as a hexadecimal string.

-record <filename>
    Record game to an input log.

-replay <filename>
    Replay game from an input log.

-speed <speed>
    Set replay speed.
]]
        os.exit(0)
      else
        error(string.format("unknown command line option '%s'", a))
      end
    else
      entrypoint_sb:write(' ', a)
    end
    argi = argi + 1
  end
  opts.entrypoint = entrypoint_sb:promote()
  return opts
end

local options: rivcm_options
local framelimiter: rivcm_framelimiter
local quit: boolean

-- Initialize application.
local function startup(): void
  io.stderr:printf('[RIVCM] Startup\n')

  -- initialize the machine
  machine = rivcm_machine.create(options.entrypoint, options.cartridge_filename)

  -- init subsystems
  rivcm_iocard.setup()
  rivcm_video.setup()
  rivcm_audio.setup()
  rivcm_input.setup()

  if options.recording then -- start recording
    rivcm_input.start_recording()
  elseif options.replaying then -- start replaying
    rivcm_input.load_replay_from_file(options.replay_filename)
  end
end

-- Terminate application.
local function shutdown(): void
  io.stderr:printf('[RIVCM] Shutdown\n')

  if options.recording then
    rivcm_input.save_replay(options.replay_filename)
  end

  if #options.outhash_filename > 0 then
    rivcm_iocard.save_outhash(options.outhash_filename)
  end
  if #options.outcard_filename > 0 then
    rivcm_iocard.save_outcard(options.outcard_filename)
  end
  rivcm_iocard.print_outcard()

  rivcm_iocard.shutdown()
  rivcm_input.shutdown()
  rivcm_video.shutdown()
  rivcm_audio.shutdown()

  machine:print_cycle_hash()
  machine:destroy()
end

-- Run the machine until it yields the next frame.
local function machine_frame(): void
  while true do
    switch machine:run() do
    case CM_BREAK_REASON_YIELDED_AUTOMATICALLY then
      -- execute control event from the yield
      switch machine:read_yield_reason() do
      case RIV_CONTROL_OPEN then
        io.stderr:printf('[RIVCM] Open RIV device\n')
        if #options.incard_filename > 0 then
          rivcm_iocard.load_incard(options.incard_filename)
        end
        -- reset input state
        rivcm_input.reset_state()
      case RIV_CONTROL_CLOSE then
        io.stderr:printf('[RIVCM] Close RIV device\n')
        -- copy output card from guest memory into host memory
        rivcm_iocard.update_outcard()
        -- copy frame buffer from guest memory into host memory
        rivcm_video.update_framebuffer()
        -- finish
        quit = true
        return
      case RIV_CONTROL_PRESENT then
        -- copy output card from guest memory into host memory
        rivcm_iocard.update_outcard()
        -- copy frame buffer from guest memory into host memory
        rivcm_video.update_framebuffer()
        -- must break the loop so we can present the video
        return
      case RIV_CONTROL_AUDIO then
        rivcm_audio.control()
      else
        error 'unknown yield reason'
      end
    case CM_BREAK_REASON_HALTED then
      io.stderr:printf('[RIVCM] Halted\n')
      quit = true
      return
    else
      error('unexpected machine break reason')
      quit = true
      return
    end
  end
end

-- Advance to the next frame.
local function advance_frame(): void
  if quit or machine:is_halted() then return end

  -- check if is the last replay frame
  local replay_finished: boolean = rivcm_input.is_replay_at_end()

  -- poll input events into machine device memory
  rivcm_input.poll()

  -- poll next frame from machine driver memory
  local mcycle_start: uint64 = machine:read_mcycle()
  local time_start: float64 = os.now()
  machine_frame()
  local now: float64 = os.now()
  local time_elapsed: float64 = now - time_start
  local mcycle_elapsed: uint64 = machine:read_mcycle() - mcycle_start

  -- force quit when replay ends
  if not quit and replay_finished then
    io.stderr:printf('[RIVCM] Finish replay\n')
    quit = true
  end

  if quit then
    sapp_quit()
  else
    framelimiter.max_fps = machine.mmio_driver.framebuffer_desc.fps * options.speed
    if options.print_stats then
      framelimiter:print_stats(now, time_elapsed, mcycle_elapsed)
    end
  end
end

-- Poll next frame.
local function frame(): void
  -- TODO: get display refresh rate
  local refresh_rate: float64 = 60
  if not machine:is_mmio_ready() then -- first frame
    advance_frame()
    framelimiter.last_frame_time = os.now()
  elseif framelimiter.max_fps <= refresh_rate then
    if framelimiter:should_process_next_frame(os.now()) then
      advance_frame()
    end
  else -- advance many frames at once when FPS is too big
    local now_start: float64 = os.now()
    local now_end: float64 = now_start + (1.0 / refresh_rate)
    local dt: float64 = 1.0 / (refresh_rate * options.speed)
    for now=now_start,<now_end,dt do
      if framelimiter:should_process_next_frame(now) then
        -- advance to next frame
        advance_frame()
      end
    end
  end
  -- display the frame
  rivcm_video.present()
end

-- parse options
options = parse_options()

-- Application main loop.
sapp_run(sapp_desc{
  init_cb = startup,
  frame_cb = frame,
  cleanup_cb = shutdown,
  event_cb = rivcm_input.append_event,
  width = 320,
  height = 240,
  window_title = "RIVCM",
})
