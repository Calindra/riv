-- This file contains all code related to keyboard/mouse input subsystem.

require 'sokol'
require 'hashmap'
require 'vector'
require 'io'
require 'arg'

require '.machine'

--------------------------------------------------------------------------------

-- Translates a sokol_app key code to a RIV key code.
local function translate_keycode_to_riv(keycode: sapp_keycode): riv_key_code
  switch keycode do
  case SAPP_KEYCODE_SPACE then return RIV_KEYCODE_SPACE
  case SAPP_KEYCODE_APOSTROPHE then return RIV_KEYCODE_APOSTROPHE
  case SAPP_KEYCODE_COMMA then return RIV_KEYCODE_COMMA
  case SAPP_KEYCODE_MINUS then return RIV_KEYCODE_MINUS
  case SAPP_KEYCODE_PERIOD then return RIV_KEYCODE_PERIOD
  case SAPP_KEYCODE_SLASH then return RIV_KEYCODE_SLASH
  case SAPP_KEYCODE_0 then return RIV_KEYCODE_0
  case SAPP_KEYCODE_1 then return RIV_KEYCODE_1
  case SAPP_KEYCODE_2 then return RIV_KEYCODE_2
  case SAPP_KEYCODE_3 then return RIV_KEYCODE_3
  case SAPP_KEYCODE_4 then return RIV_KEYCODE_4
  case SAPP_KEYCODE_5 then return RIV_KEYCODE_5
  case SAPP_KEYCODE_6 then return RIV_KEYCODE_6
  case SAPP_KEYCODE_7 then return RIV_KEYCODE_7
  case SAPP_KEYCODE_8 then return RIV_KEYCODE_8
  case SAPP_KEYCODE_9 then return RIV_KEYCODE_9
  case SAPP_KEYCODE_SEMICOLON then return RIV_KEYCODE_SEMICOLON
  case SAPP_KEYCODE_EQUAL then return RIV_KEYCODE_EQUAL
  case SAPP_KEYCODE_A then return RIV_KEYCODE_A
  case SAPP_KEYCODE_B then return RIV_KEYCODE_B
  case SAPP_KEYCODE_C then return RIV_KEYCODE_C
  case SAPP_KEYCODE_D then return RIV_KEYCODE_D
  case SAPP_KEYCODE_E then return RIV_KEYCODE_E
  case SAPP_KEYCODE_F then return RIV_KEYCODE_F
  case SAPP_KEYCODE_G then return RIV_KEYCODE_G
  case SAPP_KEYCODE_H then return RIV_KEYCODE_H
  case SAPP_KEYCODE_I then return RIV_KEYCODE_I
  case SAPP_KEYCODE_J then return RIV_KEYCODE_J
  case SAPP_KEYCODE_K then return RIV_KEYCODE_K
  case SAPP_KEYCODE_L then return RIV_KEYCODE_L
  case SAPP_KEYCODE_M then return RIV_KEYCODE_M
  case SAPP_KEYCODE_N then return RIV_KEYCODE_N
  case SAPP_KEYCODE_O then return RIV_KEYCODE_O
  case SAPP_KEYCODE_P then return RIV_KEYCODE_P
  case SAPP_KEYCODE_Q then return RIV_KEYCODE_Q
  case SAPP_KEYCODE_R then return RIV_KEYCODE_R
  case SAPP_KEYCODE_S then return RIV_KEYCODE_S
  case SAPP_KEYCODE_T then return RIV_KEYCODE_T
  case SAPP_KEYCODE_U then return RIV_KEYCODE_U
  case SAPP_KEYCODE_V then return RIV_KEYCODE_V
  case SAPP_KEYCODE_W then return RIV_KEYCODE_W
  case SAPP_KEYCODE_X then return RIV_KEYCODE_X
  case SAPP_KEYCODE_Y then return RIV_KEYCODE_Y
  case SAPP_KEYCODE_Z then return RIV_KEYCODE_Z
  case SAPP_KEYCODE_LEFT_BRACKET then return RIV_KEYCODE_LEFT_BRACKET
  case SAPP_KEYCODE_BACKSLASH then return RIV_KEYCODE_BACKSLASH
  case SAPP_KEYCODE_RIGHT_BRACKET then return RIV_KEYCODE_RIGHT_BRACKET
  case SAPP_KEYCODE_GRAVE_ACCENT then return RIV_KEYCODE_GRAVE_ACCENT
  case SAPP_KEYCODE_ESCAPE then return RIV_KEYCODE_ESCAPE
  case SAPP_KEYCODE_ENTER then return RIV_KEYCODE_ENTER
  case SAPP_KEYCODE_TAB then return RIV_KEYCODE_TAB
  case SAPP_KEYCODE_BACKSPACE then return RIV_KEYCODE_BACKSPACE
  case SAPP_KEYCODE_INSERT then return RIV_KEYCODE_INSERT
  case SAPP_KEYCODE_DELETE then return RIV_KEYCODE_DELETE
  case SAPP_KEYCODE_RIGHT then return RIV_KEYCODE_RIGHT
  case SAPP_KEYCODE_LEFT then return RIV_KEYCODE_LEFT
  case SAPP_KEYCODE_DOWN then return RIV_KEYCODE_DOWN
  case SAPP_KEYCODE_UP then return RIV_KEYCODE_UP
  case SAPP_KEYCODE_PAGE_UP then return RIV_KEYCODE_PAGE_UP
  case SAPP_KEYCODE_PAGE_DOWN then return RIV_KEYCODE_PAGE_DOWN
  case SAPP_KEYCODE_HOME then return RIV_KEYCODE_HOME
  case SAPP_KEYCODE_END then return RIV_KEYCODE_END
  case SAPP_KEYCODE_CAPS_LOCK then return RIV_KEYCODE_CAPS_LOCK
  case SAPP_KEYCODE_SCROLL_LOCK then return RIV_KEYCODE_SCROLL_LOCK
  case SAPP_KEYCODE_NUM_LOCK then return RIV_KEYCODE_NUM_LOCK
  case SAPP_KEYCODE_PRINT_SCREEN then return RIV_KEYCODE_PRINT_SCREEN
  case SAPP_KEYCODE_PAUSE then return RIV_KEYCODE_PAUSE
  case SAPP_KEYCODE_F1 then return RIV_KEYCODE_F1
  case SAPP_KEYCODE_F2 then return RIV_KEYCODE_F2
  case SAPP_KEYCODE_F3 then return RIV_KEYCODE_F3
  case SAPP_KEYCODE_F4 then return RIV_KEYCODE_F4
  case SAPP_KEYCODE_F5 then return RIV_KEYCODE_F5
  case SAPP_KEYCODE_F6 then return RIV_KEYCODE_F6
  case SAPP_KEYCODE_F7 then return RIV_KEYCODE_F7
  case SAPP_KEYCODE_F8 then return RIV_KEYCODE_F8
  case SAPP_KEYCODE_F9 then return RIV_KEYCODE_F9
  case SAPP_KEYCODE_F10 then return RIV_KEYCODE_F10
  case SAPP_KEYCODE_F11 then return RIV_KEYCODE_F11
  case SAPP_KEYCODE_F12 then return RIV_KEYCODE_F12
  case SAPP_KEYCODE_KP_0 then return RIV_KEYCODE_KP_0
  case SAPP_KEYCODE_KP_1 then return RIV_KEYCODE_KP_1
  case SAPP_KEYCODE_KP_2 then return RIV_KEYCODE_KP_2
  case SAPP_KEYCODE_KP_3 then return RIV_KEYCODE_KP_3
  case SAPP_KEYCODE_KP_4 then return RIV_KEYCODE_KP_4
  case SAPP_KEYCODE_KP_5 then return RIV_KEYCODE_KP_5
  case SAPP_KEYCODE_KP_6 then return RIV_KEYCODE_KP_6
  case SAPP_KEYCODE_KP_7 then return RIV_KEYCODE_KP_7
  case SAPP_KEYCODE_KP_8 then return RIV_KEYCODE_KP_8
  case SAPP_KEYCODE_KP_9 then return RIV_KEYCODE_KP_9
  case SAPP_KEYCODE_KP_DECIMAL then return RIV_KEYCODE_KP_DECIMAL
  case SAPP_KEYCODE_KP_DIVIDE then return RIV_KEYCODE_KP_DIVIDE
  case SAPP_KEYCODE_KP_MULTIPLY then return RIV_KEYCODE_KP_MULTIPLY
  case SAPP_KEYCODE_KP_SUBTRACT then return RIV_KEYCODE_KP_SUBTRACT
  case SAPP_KEYCODE_KP_ADD then return RIV_KEYCODE_KP_ADD
  case SAPP_KEYCODE_KP_ENTER then return RIV_KEYCODE_KP_ENTER
  case SAPP_KEYCODE_KP_EQUAL then return RIV_KEYCODE_KP_EQUAL
  case SAPP_KEYCODE_LEFT_SHIFT then return RIV_KEYCODE_LEFT_SHIFT
  case SAPP_KEYCODE_LEFT_CONTROL then return RIV_KEYCODE_LEFT_CTRL
  case SAPP_KEYCODE_LEFT_ALT then return RIV_KEYCODE_LEFT_ALT
  case SAPP_KEYCODE_LEFT_SUPER then return RIV_KEYCODE_LEFT_SUPER
  case SAPP_KEYCODE_RIGHT_SHIFT then return RIV_KEYCODE_RIGHT_SHIFT
  case SAPP_KEYCODE_RIGHT_CONTROL then return RIV_KEYCODE_RIGHT_CTRL
  case SAPP_KEYCODE_RIGHT_ALT then return RIV_KEYCODE_RIGHT_ALT
  case SAPP_KEYCODE_RIGHT_SUPER then return RIV_KEYCODE_RIGHT_SUPER
  case SAPP_KEYCODE_MENU then return RIV_KEYCODE_MENU
  else return RIV_KEYCODE_INVALID end
end

## function fn_assert(v)
  local expr_ret, expr_err: string = #[v]#
  if #expr_err ~= 0 then
    ## local funcname = context.scope:get_up_scope_of_kind('is_function').funcsym.name
    error(#[funcname .. ': ']# .. expr_err)
  end
  in expr_ret
## end

--------------------------------------------------------------------------------

local riv_event_key40: type = @record{
  key_event: uint8,
  frame: uint32,
}

local riv_input_log_header: type = @record{
  last_frame: uint32,
  num_events: uint32,
}

-- Input subsystem.
global input = @record{}

-- Input subsystem state.
local poll_events: vector(sapp_event)
local poll_event_index_by_key_code: hashmap(uint8, uint8)
local input_log_events: vector(riv_event_key40)
local input_log_last_frame: uint64
local replay_log_index: usize
local recording: boolean
local replaying: boolean

-- Initialize input subsystem.
function input.setup(): void
end

-- Terminate input subsystem.
function input.shutdown(): void
  poll_events:destroy()
  poll_event_index_by_key_code:destroy()
end

-- Poll keyboards events coming from the application window.
local function poll_keyboard_events(): void
  defer poll_event_index_by_key_code:clear() end
  local index: uint8 = 0

  --TODO: save key modifiers

  -- poll keyboard events
  for _, event: *sapp_event in mipairs(poll_events) do
    -- ignore key repeat
    if event.key_repeat then continue end
    -- ignore non key up/down events
    if not (event.type == SAPP_EVENTTYPE_KEY_DOWN or event.type == SAPP_EVENTTYPE_KEY_UP) then continue end
    -- translate key code
    local key_code: riv_key_code = translate_keycode_to_riv(event.key_code)
    -- ignore unsupported key codes
    if key_code == RIV_KEYCODE_INVALID then continue end
    -- ignore keys not tracked
    if not machine.mmio_driver.tracked_keys[key_code] then continue end
    -- compute key event
    local key_event: uint8 = key_code | (event.type == SAPP_EVENTTYPE_KEY_UP and 128_u8 or 0_u8)
    local found: boolean, prev_index: uint8 = poll_event_index_by_key_code:has_and_get(key_code)
    if found then -- replace previous event
      machine.mmio_device.key_events[prev_index] = key_event
    else -- append new event
      machine.mmio_device.key_events[index] = key_event
      poll_event_index_by_key_code[key_code] = index
      index = index + 1
      -- stop when event list is full, this is almost impossible, here just for sanity
      if index >= #machine.mmio_device.key_events then break end
    end
  end
  machine.mmio_device.key_event_count = index

  -- fill remaining key events with 0
  while index < #machine.mmio_device.key_events do
    machine.mmio_device.key_events[index] = 0
    index = index + 1
  end
end

-- Poll events coming from replay input log.
local function poll_replay_events(): void
  local frame: uint64 = machine.mmio_driver.frame

  -- fill events
  local index: uint8 = 0
  while replay_log_index < #input_log_events do
    local next_event: riv_event_key40 = input_log_events[replay_log_index]
    if next_event.frame ~= frame then break end
    replay_log_index = replay_log_index + 1
    -- append event
    machine.mmio_device.key_events[index] = next_event.key_event
    index = index + 1
    -- stop when event list is full, this is almost impossible, here just for sanity
    if index >= #machine.mmio_device.key_events then break end
  end
  machine.mmio_device.key_event_count = index

  -- fill remaining key events with 0
  while index < #machine.mmio_device.key_events do
    machine.mmio_device.key_events[index] = 0
    index = index + 1
  end
end

-- Record polled events in this frame.
local function poll_record_events(): void
  local frame: uint64 = machine.mmio_driver.frame
  input_log_last_frame = frame
  for i: uint32=0,<machine.mmio_device.key_event_count do
    input_log_events:push{
      key_event = machine.mmio_device.key_events[i],
      frame=frame,
    }
  end
end

-- Returns true if replaying and the replay is in the last frame or above last frame.
function input.is_replay_at_end(): boolean
  return replaying and machine.mmio_driver.frame >= input_log_last_frame
end

-- Poll for keyboard/mouse input events.
function input.poll(): void
  -- poll always destroy events in queue
  defer poll_events:clear() end

  -- ignore events when machine is not ready
  if not machine:is_mmio_ready() then return end

  if replaying then
    poll_replay_events()
  else
    poll_keyboard_events()
    if recording then
      poll_record_events()
    end
  end
end

-- Poll keyboard/mouse input events.
function input.append_event(event: *sapp_event): void
  if not replaying then
    poll_events:push($event)
  end
end

-- Start recording.
function input.start_recording()
  recording = true
end

-- Save replay log to a file.
function input.save_replay(filename: string): void
  local file: filestream <close> = fn_assert!(io.open(filename, 'wb'))
  local header_bytes: string <close> = string.pack('<I4I4', input_log_last_frame, input_log_events.size)
  fn_assert!(file:write(header_bytes))
  for _, event: riv_event_key40 in ipairs(input_log_events) do
    local event_bytes: string <close> = string.pack('<I1I4', event.key_event, event.frame)
    fn_assert!(file:write(event_bytes))
  end
end

-- Load replay log from a file.
function input.load_replay(filename: string): void
  replaying = true
  local file: filestream <close> = fn_assert!(io.open(filename, 'rb'))
  local num_events: uint32
  local header_bytes: string <close> = fn_assert!(file:read(8))
  input_log_last_frame, num_events = string.unpack('<I4I4', header_bytes)
  input_log_events:resize(num_events)
  for _, event: *riv_event_key40 in mipairs(input_log_events) do
    local event_bytes: string <close> = fn_assert!(file:read(5))
    event.key_event, event.frame = string.unpack('<I1I4', event_bytes)
  end
end
