-- This file contains all code related to frame limiting and frame counting.

require 'io'
require 'os'

require '.machine'

-- Frame limiter.
global framelimiter = @record{}

-- Frame limiter state.
local next_frame_time: float64
local time_elapsed_sum: float64
local mcycle_elapsed_sum: uint64
local mcycle_sum: uint64
local fps: uint64
local last_time: float64
local max_fps: uint64
local max_fps_overriden: boolean

function framelimiter.override_fps_limit(fps: uint64): void
  max_fps = fps
  max_fps_overriden = true
end

-- Limit frame rate by sleeping while necessary.
function framelimiter.wait_next_frame(): void
  local max_fps: uint64 = max_fps_overriden and max_fps or machine.mmio_driver.framebuffer_desc.fps
  if max_fps == RIV_FPS_UNLIMITED then return end
  local frame_delay: float64 = 1.0/max_fps
  local now: float64 = os.now()
  if next_frame_time > now then
    local delay: float64 = next_frame_time - now
    os.sleep(delay)
    next_frame_time = next_frame_time + frame_delay
  else
    next_frame_time = now + frame_delay
  end
end

-- Print the frame rate statistics to stderr every second.
function framelimiter.print_stats(now: float64, time_elapsed: float64, mcycle_elapsed: uint64)
  fps = fps + 1
  time_elapsed_sum = time_elapsed_sum + time_elapsed
  mcycle_elapsed_sum = mcycle_elapsed_sum + mcycle_elapsed
  local last_time_elapsed: float64 = now - last_time
  if last_time_elapsed >= 1.0 then
    if not machine:is_halted() then
      local mips: float64 = mcycle_elapsed_sum / (time_elapsed_sum * 1000000.0)
      local cpu_usage: float64 = (time_elapsed_sum * 100.0) / last_time_elapsed
      io.printf('frame=%d fps=%.2f guest_cpu_clock=%.2fMHz host_cpu_usage=%.2f%%\n',
        machine.mmio_driver.frame, fps / last_time_elapsed, mips, cpu_usage)
    end
    fps = 0
    time_elapsed_sum = 0
    mcycle_elapsed_sum = 0
    last_time = now
  end
end
